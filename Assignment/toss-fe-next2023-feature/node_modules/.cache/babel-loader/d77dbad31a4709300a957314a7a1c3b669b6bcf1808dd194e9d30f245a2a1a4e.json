{"ast":null,"code":"import { asyncToGenerator as _asyncToGenerator, regeneratorRuntime as _regeneratorRuntime } from './_virtual/_rollupPluginBabelHelpers.mjs';\n\n/** @tossdocs-ignore */\nfunction setFocusTimeout(_x, _x2) {\n  return _setFocusTimeout.apply(this, arguments);\n}\nfunction _setFocusTimeout() {\n  _setFocusTimeout = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(executeFocus, delay) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", new Promise(function (resolve) {\n              // focus가 되어 있지 않은 상태에서 async하게 focus하는 건 불가능하지만,\n              // focus가 되어 있는 상태에서 focus를 옮기는 건 가능합니다. 이를 이용한 hack입니다.\n              // 일단 focus할 fakeInput을 생성하고 보이지 않게 합니다.\n              var fakeInput = document.createElement('input');\n              fakeInput.setAttribute('type', 'text');\n              fakeInput.style.position = 'absolute';\n              fakeInput.style.opacity = '0';\n              fakeInput.style.height = '0';\n              fakeInput.style.fontSize = '16px'; // disable auto zoom\n\n              fakeInput.readOnly = true; // 실제 input을 focus하기 전에 keyboard가 올라오지 않게 합니다.\n\n              document.body.prepend(fakeInput);\n              fakeInput.focus({\n                preventScroll: true // 최상단으로 scroll되는 걸 막습니다.\n              });\n\n              setTimeout(function () {\n                executeFocus();\n                fakeInput.remove();\n                resolve(true);\n              }, delay);\n            }));\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _setFocusTimeout.apply(this, arguments);\n}\nexport { setFocusTimeout };","map":{"version":3,"names":["asyncToGenerator","_asyncToGenerator","regeneratorRuntime","_regeneratorRuntime","setFocusTimeout","_x","_x2","_setFocusTimeout","apply","arguments","mark","_callee","executeFocus","delay","wrap","_callee$","_context","prev","next","abrupt","Promise","resolve","fakeInput","document","createElement","setAttribute","style","position","opacity","height","fontSize","readOnly","body","prepend","focus","preventScroll","setTimeout","remove","stop"],"sources":["/Users/hongyelim/Study/Assignment/toss-fe-next2023-feature/node_modules/@toss/utils/esm/setFocusTimeout.mjs"],"sourcesContent":["import { asyncToGenerator as _asyncToGenerator, regeneratorRuntime as _regeneratorRuntime } from './_virtual/_rollupPluginBabelHelpers.mjs';\n\n/** @tossdocs-ignore */\nfunction setFocusTimeout(_x, _x2) {\n  return _setFocusTimeout.apply(this, arguments);\n}\n\nfunction _setFocusTimeout() {\n  _setFocusTimeout = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(executeFocus, delay) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", new Promise(function (resolve) {\n              // focus가 되어 있지 않은 상태에서 async하게 focus하는 건 불가능하지만,\n              // focus가 되어 있는 상태에서 focus를 옮기는 건 가능합니다. 이를 이용한 hack입니다.\n              // 일단 focus할 fakeInput을 생성하고 보이지 않게 합니다.\n              var fakeInput = document.createElement('input');\n              fakeInput.setAttribute('type', 'text');\n              fakeInput.style.position = 'absolute';\n              fakeInput.style.opacity = '0';\n              fakeInput.style.height = '0';\n              fakeInput.style.fontSize = '16px'; // disable auto zoom\n\n              fakeInput.readOnly = true; // 실제 input을 focus하기 전에 keyboard가 올라오지 않게 합니다.\n\n              document.body.prepend(fakeInput);\n              fakeInput.focus({\n                preventScroll: true // 최상단으로 scroll되는 걸 막습니다.\n\n              });\n              setTimeout(function () {\n                executeFocus();\n                fakeInput.remove();\n                resolve(true);\n              }, delay);\n            }));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _setFocusTimeout.apply(this, arguments);\n}\n\nexport { setFocusTimeout };\n"],"mappings":"AAAA,SAASA,gBAAgB,IAAIC,iBAAiB,EAAEC,kBAAkB,IAAIC,mBAAmB,QAAQ,0CAA0C;;AAE3I;AACA,SAASC,eAAeA,CAACC,EAAE,EAAEC,GAAG,EAAE;EAChC,OAAOC,gBAAgB,CAACC,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;AAChD;AAEA,SAASF,gBAAgBA,CAAA,EAAG;EAC1BA,gBAAgB,GAAGN,iBAAiB,EAAE,aAAaE,mBAAmB,CAAC,CAAC,CAACO,IAAI,CAAC,SAASC,OAAOA,CAACC,YAAY,EAAEC,KAAK,EAAE;IAClH,OAAOV,mBAAmB,CAAC,CAAC,CAACW,IAAI,CAAC,SAASC,QAAQA,CAACC,QAAQ,EAAE;MAC5D,OAAO,CAAC,EAAE;QACR,QAAQA,QAAQ,CAACC,IAAI,GAAGD,QAAQ,CAACE,IAAI;UACnC,KAAK,CAAC;YACJ,OAAOF,QAAQ,CAACG,MAAM,CAAC,QAAQ,EAAE,IAAIC,OAAO,CAAC,UAAUC,OAAO,EAAE;cAC9D;cACA;cACA;cACA,IAAIC,SAAS,GAAGC,QAAQ,CAACC,aAAa,CAAC,OAAO,CAAC;cAC/CF,SAAS,CAACG,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC;cACtCH,SAAS,CAACI,KAAK,CAACC,QAAQ,GAAG,UAAU;cACrCL,SAAS,CAACI,KAAK,CAACE,OAAO,GAAG,GAAG;cAC7BN,SAAS,CAACI,KAAK,CAACG,MAAM,GAAG,GAAG;cAC5BP,SAAS,CAACI,KAAK,CAACI,QAAQ,GAAG,MAAM,CAAC,CAAC;;cAEnCR,SAAS,CAACS,QAAQ,GAAG,IAAI,CAAC,CAAC;;cAE3BR,QAAQ,CAACS,IAAI,CAACC,OAAO,CAACX,SAAS,CAAC;cAChCA,SAAS,CAACY,KAAK,CAAC;gBACdC,aAAa,EAAE,IAAI,CAAC;cAEtB,CAAC,CAAC;;cACFC,UAAU,CAAC,YAAY;gBACrBxB,YAAY,CAAC,CAAC;gBACdU,SAAS,CAACe,MAAM,CAAC,CAAC;gBAClBhB,OAAO,CAAC,IAAI,CAAC;cACf,CAAC,EAAER,KAAK,CAAC;YACX,CAAC,CAAC,CAAC;UAEL,KAAK,CAAC;UACN,KAAK,KAAK;YACR,OAAOG,QAAQ,CAACsB,IAAI,CAAC,CAAC;QAC1B;MACF;IACF,CAAC,EAAE3B,OAAO,CAAC;EACb,CAAC,CAAC,CAAC;EACH,OAAOJ,gBAAgB,CAACC,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;AAChD;AAEA,SAASL,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}