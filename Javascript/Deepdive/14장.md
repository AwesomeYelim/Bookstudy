# 14장 전역변수의 문제점

## 14.1 변수의 생명 주기
### 14.1.1 지역 변수의 생명 주기
- 변수의 생명 주기 : 생성, 할당 -> 값 , 소멸과정을 겪음
- 지역변수의 생명주기 : 함수가 호출되면 생성, 함수가 종료하면 소멸

```js
function yelim(){
    var m = '지역';
    console.log(m);// 지역
    return m;
}

yelim();
console.log(yelim); //ReferenceError

//지역변수 m은 yelim함수가 호출되기 이전까지는 생성되지 않는다.
```
- 변수선언은 런타임 이전단계에 자스 엔진에 의해 먼저 실행된다.
- 지역변수의 생명주기는 함수의 생명주기와 일치함.
-> 변수는 자신이 등록된 스코프가 소멸(메모리 해제)될 때 까지 유효
- 변수의 실제 생명주기 : 메모리 공간이 확보된 시점 -> 메모리 공간 해제 -> 가용 메모리 풀에 반환되는 시점까지
- 누군가(변수, 스코프 등) 메모리 공간을 참조 하고 있으면 해제되지 않고 확보한 생태로 남아있음.

```js
var m = '전역';

function yelim(){
    console.log(m); //(1)
    var m = '지역';
}

yelim(); 
console.log(m); //전역










// (1) --> '지역' 이 안나오고 'undefined'가 나오네(?) -> 콘솔에 직접찍으면 안됨
```
- 지역변수는 함수 전체에 유효하다, 변수 할당문이 실행되기 이전까지는 undefined 값을 갖는다.
- 호이스팅은 스코프를 단위로 동작 (전역은 전역내, 지역은 지역내)
- 호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자스의 고유특징~

### 14.1.2 전역 변수의 생명 주기
- 전역코드 : 명시적 호출없이 실행, 실행되는 특별한 진입점이 없음, 반환문 사용 x, 더이상 실행할 문이 없을때 종료

- 전역객체 : 전역변수의 생명주기와 같다. 코드가 실행되기 이전단계에 먼저 생성되는 특수한 객체 
-> 프로퍼티값으로 갖는것
    - 표준 빌트인 객체 ->  Object, String, Number, Function, Array...
    - 호스트객체 -> 클라이언트 Web, 각종 API
    - var 키워드로 선언한 전역 변수, 전역 함수

- var 키워드로 선언한 전역변수는 전역객체 window의 프로퍼티
- var 키워드로 선언한 전역변수의 생명주기는 전역객체의 생명주기와 일치한다.(그림 14-2 203p, e-book 237p)


## 14.2 전역 변수의 문제점
- 암묵적 결합의 위험성 : 전역변수를 사용하겠다 -> 어디서든 참조, 할당하겠어~(암묵적 약속)-> 유효범위가 크면 코드 가독성 나빠짐, 의도치 않은 상태로 변경될 수 있는 위험성

- 긴 생명주기 : 전역변수는 생명주기가 김 -> 메모리소스 오래소비, var는 중복선언 허용 -> 의도치않은 재할당

- 스코프 체인 상에서 종점에 존재 : 변수 검색시 전역변수가 가장 마지막에 검색 -> 전역변수의 검색속도가 가장 느림(속도차 그리 크지 않음)

- 네임스페이스 오염 : 파일이 분리되어 있어도 하나의 전역 스코프를 공유함, 동일한 이름의 전역변수나 전역함수가 같은 스코프내에 존재시 -> 그 이후는 상상에 맡기겠다 -_-,,(예상치 못한 결과)

** 네임스페이스란 ? 
데이터들이 어떤 층위에 속해 있는지를 지정해 놓는 공간이다. 이름이 같은 데이터라도 층위에 따라 다른 의미를 가질 수 있기 때문에 이를 구분한다.

## 14.3 전역 변수의 사용을 억제하는 방법

- 전역변수의 무분별한사용 위험
- 왠만하면 지역변수 쓰자~
- 변수의 스코프는 좁을수록(제한되서 파악될수록) 좋음

### 14.3.1 즉시 실행 함수
- 모든 코드를 즉시실행함수로 감싸면 모든변수는 즉시 실행함수의 지역변수가 되벌임;;

```js
(function () {
    var yelim = 10; //즉시 실행함수의 지역변수
}());

console.log(yelim)//ReferenceError

// 이 방법은 전역변수 생성 x -> 라이브러리등에 자주 사용
```

### 14.3.2 네임스페이스 객체
- 네임스페이스 역활을 담당할 객체 생성 -> 전역변수처럼 사용하고 싶은 변수를 프로퍼티로 추가

```js
// 객체생성후 추가
var 전역닝겐 = {}; //전역 네임스페이스 객체

전역닝겐.name = 'yelim';

console.log(전역닝겐.name); //yelim




// 객체내에 또다른 네임스페이스 객체
var 전역닝겐 = {}; //전역 네임스페이스 객체

전역닝겐.person = {
    name: 'yelim',
    age: '20'
};

console.log(전역닝겐.person.name)// yelim

```
- 이방법은 비추 why? 네임스페이스 객체 자체가 전역변수에 할당됨으로

### 14.3.3 모듈 패턴

- 모듈패턴 : 클래스모방, 관련이 있는 변수와 함수를 모아 즉시 실행함수로 감싸 하나의 모듈을 만듬
-> 전역변수 억재, 캡슐화까지 구현

- 캡슐화 : 프로퍼티(객체의 상태를 나타냄) 와 메서드(프로퍼티를 참조하고 조작할수 있는 동작)를 하나로 묶는것//  감출 목적으로도 사용 -> 정보은닉

- 정보은닉 : 대부분의 객체지향 프로그래미 언어는 공개범위 한정을 위해 '접근제한자'(public, private, protected)를 사용
but !! 자스는 다르긔 -> 접근제한자 제공 x
-> 내부보호 기능 x 

```js
var 나예림 = (function () {
    //private 변수
    var 숫자 = 0;
    
    //외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환
    return {
        증가() {
            return ++num;
        },
        감소() {
            return --num;
        }
   };
}());

//private 변수는 외부로 노출되지 않는다.

console.log(나예림.숫자); //undefined


console.log(나예림.증가()); //1 
console.log(나예림.증가()); //2
console.log(나예림.감소()); //1
console.log(나예림.감소()); //0


//퍼블릭 멤버 : 외부로 노출되는 싶은 변수나 함수
//프라이빗 멤버 : 외부에서 접근할 수 없는 변수나 함수
```

### 14.3.4 ES6 모듈

- ES6 사용시 더는 전역변수 사용불가
- 파일자체의 독자적인 모듈 스코프 제공
- script 태그에 type = 'module' 어트리뷰트만 추가하면됨(모듈파일 확장자 mjs 권장)
```js
<script type = 'module' src = 'lib.mjs'></script>
<script type = 'module' src = 'app.mjs'></script>
```
- 구형 브라우저에선 작동 x, 잘사용 x why? 트랜스 파일링 or 번들링이 필요해서