# 11장 원시 값과 객체의 비교

- 원시타입과 객체타입은 근본적으로 다름
 - 원시값 : 변경 불가능한 값, 객체타입의 값: 변경 가능한 값
 - 원시값을 변수(확보된 메모리공간)에 할당하면 변수에 실제 값이 저장됨, 객체를 변수에 할당시 변수에는 참조값이 저장됨
 - 원시값의 변수를 다른변수에 할당하면 원시값이 복사됨, 객체를 가리키는 변수를 다른변수에 할당하면 원본의 참고값이 복사/전달 됨 ----> 참조에 의한 전달

## 11.1 원시 값
### 11.1.1 변경 불가능한 값
- 값을 변경할 수 없다 : 변경불가능 하다는것은 변수가 아닌 값에대한 진술,
읽기 전용값-> 신뢰성 보장

```js
const yelim = {};

yelim.age = 20; // 선언한 변수에 할당한 객체는 변경 ㄱㄴ
console.log(yelim)// {age : 20}
```
-  재할당시 값이 변경x, 메모리 공간의 주소가 바뀐다. ---> 불변성
- 불변성을 갖는 원시값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

(사진 139p , e-book 173p 참고)
그림 11-1 

### 11.1.2 문자열과 불변성
- 원시값인 문자열(독특) : 0개이상의 문자, 1개의 문자-> 2바이트/ 숫자값은 숫자크기에 상관 없이 동일한 8바이트
```js
//0개와 5개로 이뤄진 문자열
var yelim1 ='';
var yelim2 = 'Hello';


//자스의 문자열은 원시타입이다.(개발자의 편의성을 위해)
var name = 'yelim';
name = 'hong';
//새로운 문자열 'hong'을 다른 메모리에 저장된다. 'yelim', 'hong' 모두 메모리에 존재
```
- 문자열은 이터러블(iterable: 반복됨) 으로 배열과 유사하게 각 문자에 접근 ㄱㄴ
```js
//배열과 같은점
var name = 'yelim';

//문자열은 유사배열(배열처럼 인덱스로 프로퍼티 값에 접근 ㄱㄴ)이므로 각 문자에 접근 ㄱㄴ
console.log(name[2]); // l

console.log(name.length); // 5
console.log(name.toUpperCase());//YELIM

--------------------------------
//배열과 다른점
var name = 'yelim';

//문자열은 원시값으로 변경 x
name[2] = 'L';

console.log(name);//yelim
```

### 11.1.3 값에 의한 전달
```js
var yelim = 20; 
var hong = yelim;

console.log(yelim); //27
console.log(hong); //27

yelim = 27;

console.log(yelim); //27
console.log(hong); // ? --> 20
// 재할당된 원시값 27은 복사, 전달되지 x
----------------------------

var yelim = 20; 
var hong = yelim; //20 복사되어 할당

console.log(yelim, hong); // 20 20
console.log(yelim === hong); //true
//타입과 값이 같은것은 각 다른 메모리 공간에 저장된 별개의 이야기이다.
//그림 11-3 참고


yelim = 27;

console.log(yelim, hong); // 27 20
console.log(yelim === hong); //false
//각 저장된 메모리공간이 다르기 때문에 yelim 의 변수 값을 변경해도 hong변수 값에는 어떠한 영향도 주지 않음
// 그림 11-4 참고
```
- 변수에는 값이전달되는 것이 아닌 메모리 주소가 전달됨, 식별자는 값이아닌 메모리 주소를 기억하고 있기 때문
--> 식별자는 메모리 주소에 붙인 이름
```js 
var yelim = 20;
// 리터럴에 의해 생성된 숫자 20 -> 메모리공간의 주소 전달-> 식별자 yelim은 메모리공간을 기억함으로 숫자 20을 식별할수 있음

var hong = yelim;
//새로운 20을 생성/복사 새로운 메모리 주소를 전달(그림 11-4), yelim의 변수값 20의 메모리 주소를 그대로 전달.(그림 11-5)
```

- '값의 의한 전달'도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다.
- 두변수의 원시 값은 서로 다른 메모리 공간에 저장되어 재할당으로 값을 변경해도 서로 간섭 x

## 11.2 객체
- 프로퍼티 객수 정해져있지 x 
- 동적 추가, 삭제 가능
- 자스 객체는 프로퍼티키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있다.
- 자스는 클래스 없이 객체 생성 가능, 생성이후라도 동적으로 프로퍼티와 메서드를 추가할 수 있다.-> 사용하기는 매우편리 but 프로퍼티 접근에 비용이 더많이 듬
-> 동적 탐색대신 히든 클래스 라는 방식을 사용.
### 11.2.1 변경 가능한 값
- 객체는 변경 가능한 값
```js
var 닝겐 = {
    name : 'Hong'
};
//객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 '참조값'에 접근 할 수 있다. 
//'참조값'->메모리 공간의 주소 그자체(그림 11-7)
```

```js
// 할당이 이뤄지는 시점에 객체 리터럴 해석-> 객체 생성
var 닝겐 ={
    name : 'Hong'
};

//닝겐 변수에 저장된 참조 값으로 실제 객체 접근.
console.log(닝겐); //{name : 'hong'}
```
- 객체는 변경 가능한 값이다.-> 재할당 없이 객체 직접 변경가능-> 프로퍼티 동적추가, 갱신, 삭제 가능
```js
//얕은복사, 깊은복사에 대해 알아보자
// 얕복 : 한단계까지만 복사
// 깊복 : 객체에 중첩되있는 객체까지 모두복사
var 닝겐 = {
    name : 'Hong'
};

//프로퍼티 값 갱신
닝겐.name = 'yelim';
//프로퍼치 동적 생성
닝겐.age = '20';

console.log(닝겐); //{name : 'yelim', age : '20'}

//변수에 재할당을 하지 않았으므로 -> 객체를 할당한 변수의 참조값은 변경되지 x
```
- 구조적 단점에 따른 부작용 :  원시값과 다르게 여러개의 식별자가 하나의 객체를 공유할 수 있다는 것
```js
const 닝겐 = { x : { y : 1} };

//얕은 복사
const hong1 = {...닝겐};
console.log(hong1 === 닝겐)//false
console.log(hong1.x === 닝겐.x)//true

const _ = require('ladash');
//깊은 복사
const hong2 = _.colneYelim(o);
console.log(hong2 === o)//false
console.log(hong2.x === o.x)// false

//또 다른 경우의 얕은 복사, 깊은 복사
const yelim = 20;

//깊복
const hong1 = yelim;
console.log(hong1 === yelim);//true

const 닝겐 = {x : 1};

//얕복
const hong2 = 닝겐;
console.log(hong2 === 닝겐)//true
```
### 11.2.2 참조에 의한 전달
- 여러개의 식별자가 하나의 객체를 공유한다는것은 무엇인가? 부작용?
```js
var 닝겐 = { 
    name : 'Hong'
};

//참조값 복사(얕복)
var yelim = 닝겐;

//참조에 의한 전달 -> 두개의 식별자가 하나의 객체를 공유
//그림 11-9
--------------------

var 닝겐 = {
    name : 'Hong'
};

//얕복 ,동일한 참조값
var yelim = 닝겐;

//동일 객체 참조.
console.log( 닝겐 === yelim); //true

//닝겐을 통해 객체를 변경
닝겐.age = '20';

//닝겐과 yelim 은 동일 객체를 가리킴, 서로 영향이 있음.
console.log(닝겐); //{name : 'Hong', age : '20'}
console.log(yelim); //{name : 'Hong', age : '20'}
```
- 자스에선 '참조에 의한 전달'은 존재 x, '값에 의한 전달' 만이 존재 or '공유에 의한 전달'

- 마지막 퀴즈 (153p / e-book 187p)
```js
var 닝겐1 = { 
    name = 'hong'
};

var 닝겐2 = { 
    name = 'hong'
};

console.log(닝겐1 === 닝겐2); //false -> 다른 메모리에 저장된 별개의 객체
console.log(닝겐1.name === 닝겐2.name)//true -> 프로퍼티값을 참조하는 프로퍼티 키 닝겐1.name 과 닝겐2.name 은 같은 원시값 'hong'으로 평가된다
```html



