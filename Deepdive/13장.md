# 13장 스코프

## 13.1 스코프
- 스코프 : 자신이 선언된 위치에 의해 다른코드가 식별자 자신을 참조할 수 있는 유효범위, 식별자가 유효한 범위
"식별자를 검색하는 규칙"

```js
//함수스코프 내의 변수
function yelim(x, y){
    console.log(x, y)//2, 5
    return x + y
}

yelim(2, 5);

console.log(x, y)//ReferenceError x is not defined


//코드블록 or 함수몸체내 선언한 변수
var yelim1 = 1;//가장 바깥영역

if(true){
    var yelim2 = 2;//코드블록내
    if(true){
        var yelim3 = 3;//중첩코드블록내
    }
}

function hong(){
    var yelim4 = 4;//함수내 선언한

    function hyl(){
        var yelim5 = 5;//중첩된 함수내 선언
    }
}

console.log(yelim1); //1
console.log(yelim2); //2
console.log(yelim3); //3 
console.log(yelim4); //ReferenceError
console.log(yelim5); //ReferenceError
````
- 변수는 선언된 위치에 의해 자신의 스코프가 결정됨
--> 모든식별자(변수이름, 함수이름, 클래스이름 등)는 자신이 선언된 위치에 의해 스코프가 결정됨

```js
var yelim = '예림'

function hong() {
    var yelim = '멋진';
    console.log(yelim);
}

hong();//(1)

console.log(yelim); //(2)

//둘중 무엇을 선택할꽈 ~ ?








//이름은 동일한 'yelim'의 식별자 이지만 스코프가 다른 별개의 변수 -> (전역스코프, 함수스코프)
//(1) '멋진'
//(2) '예림'

```

- 식별자 결정 : 자스 엔진이 스코프를 통해 어떤 변수를 참조할것인지 결정하는것(코드 문맥고려)
- 렉시컬 환경 : 코드가 어디서 실행되며, 주변에 어떤코드가 있는가
- 실행 컨텍스트 : 렉시컬 환경을 구현한것
- 식별자 : 유일해야한다, 하나의 값은 유일한 식별자에게 연결. but 유효범위내에서 중복 x
-> 파일 예시
- 네임스페이스 : 데이터들이 어떤 층위에 속해 있는지를 지정해 놓는 공간이다.

--> 스코프 = 네임스페이스


- var 키워드로 선언한 변수의 중복선언
```js
// 중복선언 허용 -> 값의 재할당의 부작용
function yelim(){
    var lim = 1;

    var lim = 2;
    console.log(x); //2
}

yelim(); // 2



//let 이나 const 선언된 변수는 중복선언 허용않긔(같은스코프 내)
function hong(){
    let h = 1;
    let h = 2;
}//SyntaxError


//원시값 절대지켜
````

## 13.2 스코프의 종류
- 전역 : 코드의 가장 바깥영역 (전역스코프, 전역변수)
- 지역 : 함수 몸체 내부 (지역스코프, 지역변수)
--> 자신이 선언된 위치에 의해 자신이 유효한 범위인 스코프가 결정

### 13.2.1 전역과 전역 스코프
- 그림 13-2(193p, e-book 227p)
```js
var h = '전역 홍'
var y = '전역 예'

function 겉(){
    var l = '겉 림' //겉과 안에서만 작용

    console.log(h); //(1)
    console.log(y); //(2)
    console.log(l); //(3)

    function 안(){
        var h = '안 홍' //졸지에 지역변수

        console.log(h); //(4) //전역변수 h 가아닌 지역변수 h 참조함
        console.log(y); //(5)
        console.log(l); //(6)
    }

    안();
}
밖();

console.log(h); //(7)
console.log(l); //(8) //전역에서 참조시 ReferenceError
```
- 전역 변수는 어디서든 참조가능 -> 함수내부에서도 참조가능
- 지역 변수는 자신의 지역 스코프와 하위 지역스코프에서 유효 


## 13.3 스코프 체인
- 스코프 체인 : 스코프가 계층적으로 연결된것
(실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한것)
- 함수의 중첩 : 함수 몸체 내부에서 함수가 정의된 현상
- 중첩 함수 : 함수 몸체 내부에 정의된 함수
- 외부 함수 : 중첩 함수를 포함하는 함수
- 상위 스코프 : 외부 함수의 상위 스코프
- 함수는 지역 스코프도 중첩될 수 있다. -> 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다.

- 그림 13-2 참고
    - '안' 함수는 '겉' 함수의 중첩함수
    - '겉' 함수 지역스코프는 '안' 함수 지역스코프의 상위스코프
    - '겉' 함수 지역스코프의 상위스코프는 전역스코프

- 자스 엔진의 검색원리 : 변수참조시) 스코프체인을 통해) 변수를 참조하는 코드의 스코프 -> 상위 스코프 -> 선언된 변수 검색
  

### 13.3.1 스코프 체인에 의한 변수 검색
(그림 13-2)

```js
var h = '전역 홍'
var y = '전역 예'

function 겉(){
    var l = '겉 림' //겉과 안에서만 작용

    console.log(h); //(1)
    console.log(y); //(2)
    console.log(l); //(3)

    function 안(){
        var h = '안 홍' //졸지에 지역변수

        console.log(h); //(4) //전역변수 h 가아닌 지역변수 h 참조함
        console.log(y); //(5)
        console.log(l); //(6)
    }

    안();
}
밖();

console.log(h); //(7)
console.log(l); //(8) //전역에서 참조시 ReferenceError
```
- 자스 엔진 작동 원리
    - (4) : h 로 선언된 변수를 '안' 지역 스코프내에서 찾음 -> 있음, 그 값대로 출력
    - (5) : y 로 선언된 변수를 '안' 지역 스코프내에서 찾음 -> 없음 -> 상위('겉')스코프로 이동 -> 없음 -> 전역스코프로 이동 -> 있음, 그 값대로 출력
    - (6) : l 로 선언된 변수를 '안' 지역 스코프내에서 찾음 -> 없음 -> 상위('겉')스코프로 이동 -> 있음, 그 값대로 출력
- 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조 삽 ㄱㄴ

### 13.3.2 스코프 체인에 의한 함수 검색
```js
//전역 함수
function yelim(){
    console.log('전역 함수 예림')
}

function hong(){
    //중첩 함수
    function yelim(){
        console.log('지역 함수 예림');
    }
    yelim();//(1)
}
hong();

//함수 선언문 -> 런타임 이전에 함수객체가 먼저 생성, 자스엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언 -> 생성된 함수 객체를 할당
//(1)을 호출시 자스 엔진은 식별자 yelim을 검색
//함수도 식별자에 할당됨으로 스코프를 갖는다
//스코프 : 식별자를 검색하는 규칙
```

## 13.4 함수 레벨 스코프
- 코드블록이 아닌 함수에 의해서만 지역스코프가 생성
- 대부분의 프로그래밍 언어의 모든 코드블록(if, for, while, try/catch)은 지역스코프를 만든다. -> 블록 레벨 스코프
- but ! ! var 로 선언된 변수 -> 함수 코드블록(몸체)만을 지역스코프로 인정한다.-> 함수레벨스코프

```js
//only var ! !
//1)
var y = 1; //누가봐도 전역변수
if(1){
    var y = 10; //y는 지역스코프 범위가 아닌, 중복선언, 의도치 않게 변수값 변경되는 부작용 발생
}
console.log(y); //10


//2)
var l = 10; 

//l은 for 문에 의해서 중복 선언된다.
for(var l = 0; l < 5; i++){
    console.log(l); // 0 1 2 3 4
}

//의도치 않게 값 변경
console.log(l); //5 -> Why? for문에서 5 미만이기때문에 그 이하값이 for 문내에 출력되고 다음값인 5가 출력이 되는것
```
- let, const는 블록 레벨 스코프를 지원 -> 15장 참고

## 13.5 렉시컬 스코프

```js
var y = 1; 

function yelim(){
    var y = 10; //정의
    hong(); //호출
}

function hong(){//전역함수
    console.log(y); //출력
}

yelim();// ?
hong();// ?

//두 가지 패턴 예측
// 1. 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정 -> 동적 스코프
// 2. 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정 -> 렉시컬 스코프, 정적스코프 -> 자스는 렉시컬 스코프를 따름

//정의가 먼저인가? 호출이 먼저인가? 정의가 먼저
//함수의 상위스코프는 always 자신이 정의된 스코프
//함수의 정의가 실행되어 생성된 함수객체는 상위 스코프를 기억한다 -> 함수 호출시 상위스코프를 참고해야하기 때문












yelim();// 1
hong();// 1
```